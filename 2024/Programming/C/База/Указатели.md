> Указатель — это переменная, в которой хранится адрес памяти объекта

От любой переменной можно взять адрес при помощи операции взятия адреса "_&_". Эта операция возвращает указатель
```C
int *y = &x;
```

Указатель можно разыменовать при помощи операции разыменовывания "_*_ ". Это операция возвращает тот объект, на который указывает указатель
```C
int z = *y;
```

Для адресов в памяти применяется шестнадцатеричная система.

Так как переменная _x_ представляет тип int, то она будет занимать следующие 4 байта. Таким образом, переменная типа int последовательно займет ячейки памяти с адресами, например 0x0060FEA8, 0x0060FEA9, 0x0060FEAA, 0x0060FEAB.
![[Pasted image 20241015224346.png]]
И указатель _y_ будет ссылаться на адрес, по которому располагается переменная _x_, то есть на адрес 0x0060FEA8.

### Операции с указателями
### Присваивание
Чтобы изменить значение переменной по указателю, нужно разыменовать ее и присвоить ей другое значение
Код:
```C
int x = 0;
int *y = &x;
*y = 10;
printf("%d", x);
```
 Программа выведет 10.

### Сложение
Если сложить указатель с числом, то мы получим переменную, которая храниться в следующей ячейке памяти. В основном это используется для массивов(потому что элементы массива хранятся в памяти последовательно)
Код:
```C
int A[] = {1, 2, 3, 4, 5};
printf("%d", *(A + 1));
```

Этот код выведет _2_, так как массив это ссылка на первый его элемент

**Вычитание работает по аналогии**

### Константные ссылки
Константная ссылка позволяет хранить в себе адрес элемента, но не менять его, при этом сам адрес ячейки можно поменять
Код:
```C
int A[2] = {100, 200};
const int *a0 = A;
printf("content of a0 = %d\n", *a0);

//*a0 *= 10; //error: cannot change constant value.

a0 = (A + 1); // A[1]

printf("content of a0 = %d\n", *a0); //prints: A[1]
```
В примере выше была создана переменная-указатель, ссылающееся на постоянное значение. Слово **const** перед звёздочкой указывает, что нельзя менять содержимое напрямую (путём разыменования, обращения к ячейке). Но сама переменная указатель постоянной не является. А значит, ей можно присвоить новый адрес. Например, адрес следующей ячейки в массиве.
