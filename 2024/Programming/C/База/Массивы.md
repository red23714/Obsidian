[[Типы данных]]
[[Указатели]]

> Массив – это линейно упорядоченная совокупность однотипных элементов.

Массив определяется _типом_ элементов (int, double и т.д.) и _длиной_. Доступ к элементам осуществляется по индексу – порядковому номеру элемента массива. Логически первый элемент массива имеет индекс ноль. В языке Си существуют [[#Статические массивы|статические массивы]] число элементов в которых должно быть известно в момент компиляции программы, и [[#Динамические массивы|динамические массивы]], размер которых задается в процессе выполнения программы, то есть может зависеть от входных данных. Эти два типа отличаются только методом создания массива, поэтому сначала рассмотрим статические массивы.

## Статические массивы
### Способы объявления статических массивов
###### Стандартное объявление с указанием константой длины:
```C
double points[100];
```
###### Объявление массива с присвоением значений его элементам:
```C
double points[] = {1.0, 3.14, -1.2, 12.65};
```

###### Объявление массива с заполнением его однотипных значений:
```C
double points[12] = {1.0};
```

### Представление массива в памяти и адресная арифметика
В памяти элементы массива записаны последовательно без пропусков. Имя массива является указателем на его начальный элемент (с индексом 0). Поскольку в массиве все элементы имеют одинаковый тип, то зная адрес начала массива (A), размер одного элемента (size) и индекс k можно вычислить адрес размещения k-ого элемента: $$A + k * size$$
В языке Си **к указателям можно прибавлять целые числа**. Например, если есть указатель `double *a;`, то значением выражения `a+9` будет адрес десятого элемента массива, который начинается с адреса `a`. Компилятор сам понимает, что `a` является указателем на double и прибавляет нужное значение.

### Передача массива в функцию
В функцию передается адрес начала массива и его длина:
```C
int print_array(double x[], int len);
```

Пример кода:
```C
int print_array(double x[], int len) 
{ 
	int k; 
	
	for(k = 0; k < len; k++) 
	{ 
		printf("x[%d] = %lf\n", k, x[k]); 
	} 
	
	return 0; 
}

int main() 
{ 
	double points[] = {1.0, 3.14, -1.2, 12.65}; 
	int npoints = sizeof(points) / sizeof(points[0]); 
	
	print_array(points, npoints); 
	
	return 0; 
}
```

>Если функция **print_array** изменит значение элемента массива `x` (например, в цикле будет написано `x[k]=0;`), то изменятся значения и в массиве `points` функции `main`. Элементы массива при вызове функций не копируются! Функция получает на вход адрес памяти, где записаны элементы массива.

## Динамические массивы

> Динамические массивы — это массивы, память для хранения которых выделяется в момент выполнения программы

Для работы с динамической памятью существуют функции `malloc` (**m**emory **alloc**ation — выделение памяти) и `free` (освобождение). Для использования функций нужна библиотека `<stdlib.h>`.

###### malloc()
Прототип:
`void *malloc(size_t size);`

Параметры:
`size` — беззнаковое целое число, размер запрашиваемой памяти в _байтах_.

Возвращает:
Адрес начала выделенной памяти или NULL, если не удалось выделить память.

Функция _malloc()_ возвращает указатель типа `void *` — это "абстрактный" указатель на память, который может быть приведен к указателю на любой тип.

Пример создания динамического массива:
```C
int length; 
int *points; 

points = (int *)malloc(length * sizeof(int));
```

> Работа с динамичными массивами осуществляется как и с обычными массивами

###### free()
Прототип
`void free(void *ptr);`

Параметры:
`ptr` — указатель, который был получен в результат вызова malloc.

В качестве аргумента функции _free()_ может использоваться только тот адрес, который был получен в результате вызова malloc. Нельзя создать статический массив и "освободить" его функцией free. Адрес может быть освобожден только один раз. Если два раза подряд вызвать функцию _free()_ с одним и тем же аргументом, то это приведет к аварийному завершению программы.

Пример с тем же массивом points:
```C
free(points);
```

## Передача массива из функции
Стандартный массив нельзя передать из функции, так как после окончания работы функции локальные переменные удаляются. 
Для передачи локального массива внутри функции нужно выделить память через функцию _malloc()_ 
Пример:
```C
char *foo()
{
    char* ans = (char*)malloc(n * sizeof(char));

    return ans;
}
```

Полезные ссылки:
[[https://prog-cpp.ru/c-massiv/]]